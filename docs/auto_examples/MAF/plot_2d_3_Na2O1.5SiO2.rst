
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/MAF/plot_2d_3_Na2O1.5SiO2.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_examples_MAF_plot_2d_3_Na2O1.5SiO2.py>`
        to download the full example code or to run this example in your browser via Binder

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_MAF_plot_2d_3_Na2O1.5SiO2.py:


2D MAF data of 2Na2O.3SiO2 glass
================================

.. GENERATED FROM PYTHON SOURCE LINES 8-17

The following example illustrates an application of the statistical learning method
applied in determining the distribution of the nuclear shielding tensor parameters
from a 2D magic-angle flipping (MAF) spectrum. In this example, we use the 2D MAF
spectrum [#f1]_ of :math:`2\text{Na}_2\text{O}\cdot3\text{SiO}_2` glass.

Before getting started
----------------------

Import all relevant packages.

.. GENERATED FROM PYTHON SOURCE LINES 17-27

.. code-block:: default

    import csdmpy as cp
    import matplotlib.pyplot as plt
    import numpy as np
    from matplotlib import cm

    from mrinversion.kernel.nmr import ShieldingPALineshape
    from mrinversion.linear_model import SmoothLasso, TSVDCompression
    from mrinversion.utils import plot_3d, to_Haeberlen_grid









.. GENERATED FROM PYTHON SOURCE LINES 29-30

Setup for the matplotlib figures.

.. GENERATED FROM PYTHON SOURCE LINES 30-42

.. code-block:: default



    def plot2D(csdm_object, **kwargs):
        plt.figure(figsize=(4.5, 3.5))
        ax = plt.subplot(projection="csdm")
        ax.imshow(csdm_object, cmap="gist_ncar_r", aspect="auto", **kwargs)
        ax.invert_xaxis()
        ax.invert_yaxis()
        plt.tight_layout()
        plt.show()









.. GENERATED FROM PYTHON SOURCE LINES 43-50

Dataset setup
-------------

Import the dataset
''''''''''''''''''

Load the dataset. Here, we import the dataset as the CSDM data-object.

.. GENERATED FROM PYTHON SOURCE LINES 50-61

.. code-block:: default


    # The 2D MAF dataset in csdm format
    filename = "https://sandbox.zenodo.org/record/1065347/files/2Na2O_3SiO2_MAF.csdf"
    data_object = cp.load(filename)

    # For inversion, we only interest ourselves with the real part of the complex dataset.
    data_object = data_object.real

    # We will also convert the coordinates of both dimensions from Hz to ppm.
    _ = [item.to("ppm", "nmr_frequency_ratio") for item in data_object.dimensions]








.. GENERATED FROM PYTHON SOURCE LINES 62-66

Here, the variable ``data_object`` is a
`CSDM <https://csdmpy.readthedocs.io/en/latest/api/CSDM.html>`_
object that holds the real part of the 2D MAF dataset. The plot of the 2D MAF dataset
is

.. GENERATED FROM PYTHON SOURCE LINES 66-68

.. code-block:: default

    plot2D(data_object)




.. image-sg:: /auto_examples/MAF/images/sphx_glr_plot_2d_3_Na2O1.5SiO2_001.png
   :alt: plot 2d 3 Na2O1.5SiO2
   :srcset: /auto_examples/MAF/images/sphx_glr_plot_2d_3_Na2O1.5SiO2_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 69-89

There are two dimensions in this dataset. The dimension at index 0 is the pure
anisotropic dimension, while the dimension at index 1 is the isotropic chemical shift
dimension.

Prepping the data for inversion
'''''''''''''''''''''''''''''''
**Step-1: Data Alignment**

When using the csdm objects with the ``mrinversion`` package, the dimension at index
0 must be the dimension undergoing the linear inversion. In this example, we plan to
invert the pure anisotropic shielding line-shape. In the ``data_object``, the
anisotropic dimension is already at index 0 and, therefore, no further action is
required.

**Step-2: Optimization**

Also notice, the signal from the 2D MAF dataset occupies a small fraction of the
two-dimensional frequency grid. For optimum performance, truncate the dataset to the
relevant region before proceeding. Use the appropriate array indexing/slicing to
select the signal region.

.. GENERATED FROM PYTHON SOURCE LINES 89-92

.. code-block:: default

    data_object_truncated = data_object[:, 220:280]
    plot2D(data_object_truncated)




.. image-sg:: /auto_examples/MAF/images/sphx_glr_plot_2d_3_Na2O1.5SiO2_002.png
   :alt: plot 2d 3 Na2O1.5SiO2
   :srcset: /auto_examples/MAF/images/sphx_glr_plot_2d_3_Na2O1.5SiO2_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 93-103

Linear Inversion setup
----------------------

Dimension setup
'''''''''''''''

**Anisotropic-dimension:**
The dimension of the dataset that holds the pure anisotropic frequency
contributions. In ``mrinversion``, this must always be the dimension at index 0 of
the data object.

.. GENERATED FROM PYTHON SOURCE LINES 103-105

.. code-block:: default

    anisotropic_dimension = data_object_truncated.dimensions[0]








.. GENERATED FROM PYTHON SOURCE LINES 106-108

**x-y dimensions:**
The two inverse dimensions corresponding to the `x` and `y`-axis of the `x`-`y` grid.

.. GENERATED FROM PYTHON SOURCE LINES 108-113

.. code-block:: default

    inverse_dimensions = [
        cp.LinearDimension(count=25, increment="500 Hz", label="x"),  # the `x`-dimension.
        cp.LinearDimension(count=25, increment="500 Hz", label="y"),  # the `y`-dimension.
    ]








.. GENERATED FROM PYTHON SOURCE LINES 114-121

Generating the kernel
'''''''''''''''''''''

For MAF datasets, the line-shape kernel corresponds to the pure nuclear shielding
anisotropy line-shapes. Use the
:class:`~mrinversion.kernel.nmr.ShieldingPALineshape` class to generate a
shielding line-shape kernel.

.. GENERATED FROM PYTHON SOURCE LINES 121-131

.. code-block:: default

    lineshape = ShieldingPALineshape(
        anisotropic_dimension=anisotropic_dimension,
        inverse_dimension=inverse_dimensions,
        channel="29Si",
        magnetic_flux_density="9.4 T",
        rotor_angle="90°",
        rotor_frequency="12 kHz",
        number_of_sidebands=4,
    )








.. GENERATED FROM PYTHON SOURCE LINES 132-147

Here, ``lineshape`` is an instance of the
:class:`~mrinversion.kernel.nmr.ShieldingPALineshape` class. The required
arguments of this class are the `anisotropic_dimension`, `inverse_dimension`, and
`channel`. We have already defined the first two arguments in the previous
sub-section. The value of the `channel` argument is the nucleus observed in the MAF
experiment. In this example, this value is '29Si'.
The remaining arguments, such as the `magnetic_flux_density`, `rotor_angle`,
and `rotor_frequency`, are set to match the conditions under which the 2D MAF
spectrum was acquired. The value of the `number_of_sidebands` argument is the number
of sidebands calculated for each line-shape within the kernel. Unless, you have a lot
of spinning sidebands in your MAF dataset, four sidebands should be enough.

Once the ShieldingPALineshape instance is created, use the
:meth:`~mrinversion.kernel.nmr.ShieldingPALineshape.kernel` method of the
instance to generate the MAF line-shape kernel.

.. GENERATED FROM PYTHON SOURCE LINES 147-150

.. code-block:: default

    K = lineshape.kernel(supersampling=1)
    print(K.shape)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    (128, 625)




.. GENERATED FROM PYTHON SOURCE LINES 151-154

The kernel ``K`` is a NumPy array of shape (128, 625), where the axes with 128 and
625 points are the anisotropic dimension and the features (x-y coordinates)
corresponding to the :math:`25\times 25` `x`-`y` grid, respectively.

.. GENERATED FROM PYTHON SOURCE LINES 156-161

Data Compression
''''''''''''''''

Data compression is optional but recommended. It may reduce the size of the
inverse problem and, thus, further computation time.

.. GENERATED FROM PYTHON SOURCE LINES 161-167

.. code-block:: default

    new_system = TSVDCompression(K, data_object_truncated)
    compressed_K = new_system.compressed_K
    compressed_s = new_system.compressed_s

    print(f"truncation_index = {new_system.truncation_index}")





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    compression factor = 1.1851851851851851
    truncation_index = 108




.. GENERATED FROM PYTHON SOURCE LINES 168-181

Solving the inverse problem
---------------------------

Smooth LASSO cross-validation
'''''''''''''''''''''''''''''

Solve the smooth-lasso problem. Ordinarily, one should use the statistical learning
method to solve the inverse problem over a range of α and λ values and then determine
the best nuclear shielding tensor parameter distribution for the given 2D MAF
dataset. Considering the limited build time for the documentation, we skip this step
and evaluate the distribution at pre-optimized α and λ values. The optimum values are
:math:`\alpha = 2.2\times 10^{-8}` and :math:`\lambda = 1.27\times 10^{-6}`.
The following commented code was used in determining the optimum α and λ values.

.. GENERATED FROM PYTHON SOURCE LINES 183-214

.. code-block:: default


    # from mrinversion.linear_model import SmoothLassoCV
    # import numpy as np

    # # setup the pre-defined range of alpha and lambda values
    # lambdas = 10 ** (-4 - 3 * (np.arange(20) / 19))
    # alphas = 10 ** (-4.5 - 5 * (np.arange(20) / 19))

    # # setup the smooth lasso cross-validation class
    # s_lasso = SmoothLassoCV(
    #     alphas=alphas,  # A numpy array of alpha values.
    #     lambdas=lambdas,  # A numpy array of lambda values.
    #     sigma=0.003,  # The standard deviation of noise from the MAF data.
    #     folds=10,  # The number of folds in n-folds cross-validation.
    #     inverse_dimension=inverse_dimensions,  # previously defined inverse dimensions.
    #     verbose=1,  # If non-zero, prints the progress as the computation proceeds.
    # )

    # # run fit using the compressed kernel and compressed data.
    # s_lasso.fit(compressed_K, compressed_s)

    # # the optimum hyper-parameters, alpha and lambda, from the cross-validation.
    # print(s_lasso.hyperparameters)
    # # {'alpha': 2.198392648862289e-08, 'lambda': 1.2742749857031348e-06}

    # # the solution
    # f_sol = s_lasso.f

    # # the cross-validation error curve
    # CV_metric = s_lasso.cross_validation_curve








.. GENERATED FROM PYTHON SOURCE LINES 215-216

If you use the above ``SmoothLassoCV`` method, skip the following code-block.

.. GENERATED FROM PYTHON SOURCE LINES 216-224

.. code-block:: default


    # Setup the smooth lasso class
    s_lasso = SmoothLasso(
        alpha=2.198e-8, lambda1=1.27e-6, inverse_dimension=inverse_dimensions
    )
    # run the fit method on the compressed kernel and compressed data.
    s_lasso.fit(K=compressed_K, s=compressed_s)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    /Users/philip/GitHub/mrinversion/mrinversion/linear_model/_base_l1l2.py:183: RuntimeWarning: divide by zero encountered in log10
      coords = np.log10(dim.coordinates.value)




.. GENERATED FROM PYTHON SOURCE LINES 225-230

The optimum solution
''''''''''''''''''''

The :attr:`~mrinversion.linear_model.SmoothLasso.f` attribute of the instance holds
the solution,

.. GENERATED FROM PYTHON SOURCE LINES 230-232

.. code-block:: default

    f_sol = s_lasso.f  # f_sol is a CSDM object.








.. GENERATED FROM PYTHON SOURCE LINES 233-240

where ``f_sol`` is the optimum solution.

The fit residuals
'''''''''''''''''

To calculate the residuals between the data and predicted data(fit), use the
:meth:`~mrinversion.linear_model.SmoothLasso.residuals` method, as follows,

.. GENERATED FROM PYTHON SOURCE LINES 240-246

.. code-block:: default

    residuals = s_lasso.residuals(K=K, s=data_object_truncated)
    # residuals is a CSDM object.

    # The plot of the residuals.
    plot2D(residuals, vmax=data_object_truncated.max(), vmin=data_object_truncated.min())




.. image-sg:: /auto_examples/MAF/images/sphx_glr_plot_2d_3_Na2O1.5SiO2_003.png
   :alt: plot 2d 3 Na2O1.5SiO2
   :srcset: /auto_examples/MAF/images/sphx_glr_plot_2d_3_Na2O1.5SiO2_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 247-248

The standard deviation of the residuals is

.. GENERATED FROM PYTHON SOURCE LINES 248-250

.. code-block:: default

    residuals.std()





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    <Quantity 0.00330886>



.. GENERATED FROM PYTHON SOURCE LINES 251-256

Saving the solution
'''''''''''''''''''

To serialize the solution to a file, use the `save()` method of the CSDM object,
for example,

.. GENERATED FROM PYTHON SOURCE LINES 256-259

.. code-block:: default

    f_sol.save("2Na2O.3SiO2_inverse.csdf")  # save the solution
    residuals.save("2Na2O.3SiO2_residue.csdf")  # save the residuals








.. GENERATED FROM PYTHON SOURCE LINES 260-271

Data Visualization
------------------

At this point, we have solved the inverse problem and obtained an optimum
distribution of the nuclear shielding tensor parameters from the 2D MAF dataset. You
may use any data visualization and interpretation tool of choice for further
analysis. In the following sections, we provide minimal visualization to complete the
case study.

Visualizing the 3D solution
'''''''''''''''''''''''''''

.. GENERATED FROM PYTHON SOURCE LINES 271-285

.. code-block:: default


    # Normalize the solution
    f_sol /= f_sol.max()

    # Convert the coordinates of the solution, `f_sol`, from Hz to ppm.
    [item.to("ppm", "nmr_frequency_ratio") for item in f_sol.dimensions]

    # The 3D plot of the solution
    plt.figure(figsize=(5, 4.4))
    ax = plt.subplot(projection="3d")
    plot_3d(ax, f_sol, elev=25, azim=-50, x_lim=[0, 150], y_lim=[0, 150], z_lim=[-60, -120])
    plt.tight_layout()
    plt.show()




.. image-sg:: /auto_examples/MAF/images/sphx_glr_plot_2d_3_Na2O1.5SiO2_004.png
   :alt: plot 2d 3 Na2O1.5SiO2
   :srcset: /auto_examples/MAF/images/sphx_glr_plot_2d_3_Na2O1.5SiO2_004.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 286-292

From the 3D plot, we observe three distinct regions corresponding to the
:math:`\text{Q}^4`, :math:`\text{Q}^3`, and :math:`\text{Q}^2` sites, respectively.
The :math:`\text{Q}^4` sites are resolved in the 3D distribution; however, we observe
partial overlapping :math:`\text{Q}^3` and :math:`\text{Q}^2` sites. The following is
a naive selection of the three regions. One may also apply sophisticated
classification algorithms to better quantify the Q-species.

.. GENERATED FROM PYTHON SOURCE LINES 292-302

.. code-block:: default


    Q4_region = f_sol[0:6, 0:6, 14:35] * 3
    Q4_region.description = "Q4 region x 3"

    Q3_region = f_sol[0:8, 7:, 20:39]
    Q3_region.description = "Q3 region"

    Q2_region = f_sol[:10, 6:18, 36:52]
    Q2_region.description = "Q2 region"








.. GENERATED FROM PYTHON SOURCE LINES 303-304

An approximate plot of the respective regions is shown below.

.. GENERATED FROM PYTHON SOURCE LINES 304-362

.. code-block:: default


    # Calculate the normalization factor for the 2D contours and 1D projections from the
    # original solution, `f_sol`. Use this normalization factor to scale the intensities
    # from the sub-regions.
    max_2d = [
        f_sol.sum(axis=0).max().value,
        f_sol.sum(axis=1).max().value,
        f_sol.sum(axis=2).max().value,
    ]
    max_1d = [
        f_sol.sum(axis=(1, 2)).max().value,
        f_sol.sum(axis=(0, 2)).max().value,
        f_sol.sum(axis=(0, 1)).max().value,
    ]

    plt.figure(figsize=(5, 4.4))
    ax = plt.subplot(projection="3d")

    # plot for the Q4 region
    plot_3d(
        ax,
        Q4_region,
        x_lim=[0, 150],  # the x-limit
        y_lim=[0, 150],  # the y-limit
        z_lim=[-60, -120],  # the z-limit
        max_2d=max_2d,  # normalization factors for the 2D contours projections
        max_1d=max_1d,  # normalization factors for the 1D projections
        cmap=cm.Reds_r,  # colormap
    )
    # plot for the Q3 region
    plot_3d(
        ax,
        Q3_region,
        x_lim=[0, 150],  # the x-limit
        y_lim=[0, 150],  # the y-limit
        z_lim=[-60, -120],  # the z-limit
        max_2d=max_2d,  # normalization factors for the 2D contours projections
        max_1d=max_1d,  # normalization factors for the 1D projections
        cmap=cm.Blues_r,  # colormap
    )
    # plot for the Q2 region
    plot_3d(
        ax,
        Q2_region,
        elev=25,  # the elevation angle in the z plane
        azim=-50,  # the azimuth angle in the x-y plane
        x_lim=[0, 150],  # the x-limit
        y_lim=[0, 150],  # the y-limit
        z_lim=[-60, -120],  # the z-limit
        max_2d=max_2d,  # normalization factors for the 2D contours projections
        max_1d=max_1d,  # normalization factors for the 1D projections
        cmap=cm.Oranges_r,  # colormap
        box=False,  # draw a box around the region
    )
    ax.legend()
    plt.tight_layout()
    plt.show()




.. image-sg:: /auto_examples/MAF/images/sphx_glr_plot_2d_3_Na2O1.5SiO2_005.png
   :alt: plot 2d 3 Na2O1.5SiO2
   :srcset: /auto_examples/MAF/images/sphx_glr_plot_2d_3_Na2O1.5SiO2_005.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 363-368

Convert the 3D tensor distribution in Haeberlen parameters
----------------------------------------------------------
You may re-bin the 3D tensor parameter distribution from a
:math:`\rho(\delta_\text{iso}, x, y)` distribution to
:math:`\rho(\delta_\text{iso}, \zeta_\sigma, \eta_\sigma)` distribution as follows.

.. GENERATED FROM PYTHON SOURCE LINES 368-376

.. code-block:: default


    # Create the zeta and eta dimensions,, as shown below.
    zeta = cp.as_dimension(np.arange(40) * 4 - 40, unit="ppm", label="zeta")
    eta = cp.as_dimension(np.arange(16) / 15, label="eta")

    # Use the `to_Haeberlen_grid` function to convert the tensor parameter distribution.
    fsol_Hae = to_Haeberlen_grid(f_sol, zeta, eta)








.. GENERATED FROM PYTHON SOURCE LINES 377-379

The 3D plot
'''''''''''

.. GENERATED FROM PYTHON SOURCE LINES 379-385

.. code-block:: default

    plt.figure(figsize=(5, 4.4))
    ax = plt.subplot(projection="3d")
    plot_3d(ax, fsol_Hae, x_lim=[0, 1], y_lim=[-40, 120], z_lim=[-60, -120], alpha=0.1)
    plt.tight_layout()
    plt.show()




.. image-sg:: /auto_examples/MAF/images/sphx_glr_plot_2d_3_Na2O1.5SiO2_006.png
   :alt: plot 2d 3 Na2O1.5SiO2
   :srcset: /auto_examples/MAF/images/sphx_glr_plot_2d_3_Na2O1.5SiO2_006.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 386-394

References
----------

.. [#f1] Zhang, P., Dunlap, C., Florian, P., Grandinetti, P. J., Farnan, I., Stebbins
      , J. F. Silicon site distributions in an alkali silicate glass derived by
      two-dimensional 29Si nuclear magnetic resonance, J. Non. Cryst. Solids, **204**,
      (1996), 294–300. `doi:10.1016/S0022-3093(96)00601-1
      <https://doi.org/doi:10.1016/S0022-3093(96)00601-1>`_.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  14.054 seconds)


.. _sphx_glr_download_auto_examples_MAF_plot_2d_3_Na2O1.5SiO2.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example


  .. container:: binder-badge

    .. image:: images/binder_badge_logo.svg
      :target: https://mybinder.org/v2/gh/DeepanshS/mrinversion/master?urlpath=lab/tree/docs/_build/html/../../notebooks/auto_examples/MAF/plot_2d_3_Na2O1.5SiO2.ipynb
      :alt: Launch binder
      :width: 150 px


  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_2d_3_Na2O1.5SiO2.py <plot_2d_3_Na2O1.5SiO2.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_2d_3_Na2O1.5SiO2.ipynb <plot_2d_3_Na2O1.5SiO2.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
