
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/synthetic/plot_1D_2_sideband_bimodal.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_examples_synthetic_plot_1D_2_sideband_bimodal.py>`
        to download the full example code or to run this example in your browser via Binder

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_synthetic_plot_1D_2_sideband_bimodal.py:


Bimodal distribution (Aniso Shielding Sideband Inversion)
=========================================================

.. GENERATED FROM PYTHON SOURCE LINES 8-17

The following example demonstrates the statistical learning based determination of
nuclear shielding tensor parameters from a one-dimensional cross-section of a
spinning sideband correlation spectrum. In this example, we use a synthetic
sideband amplitude spectrum from a bimodal tensor distribution.

Before getting started
----------------------

Import all relevant packages.

.. GENERATED FROM PYTHON SOURCE LINES 17-42

.. code-block:: default

    import csdmpy as cp
    import matplotlib.pyplot as plt
    import numpy as np

    from mrinversion.kernel.nmr import ShieldingPALineshape
    from mrinversion.linear_model import SmoothLasso, SmoothLassoCV, TSVDCompression
    from mrinversion.utils import get_polar_grids

    # Setup for the matplotlib figures


    # function for 2D x-y plot.
    def plot2D(ax, csdm_object, title=""):
        # convert the dimension coordinates of the csdm_object from Hz to pmm.
        _ = [item.to("ppm", "nmr_frequency_ratio") for item in csdm_object.dimensions]

        levels = (np.arange(9) + 1) / 10
        plt.figure(figsize=(4.5, 3.5))
        ax.contourf(csdm_object, cmap="gist_ncar", levels=levels)
        ax.grid(None)
        ax.set_title(title)
        get_polar_grids(ax)
        ax.set_aspect("equal")









.. GENERATED FROM PYTHON SOURCE LINES 43-50

Dataset setup
-------------

Import the dataset
''''''''''''''''''

Load the dataset. Here, we import the dataset as a CSDM data-object.

.. GENERATED FROM PYTHON SOURCE LINES 50-59

.. code-block:: default


    # the 1D spinning sideband cross-section data in csdm format
    domain = "https://sandbox.zenodo.org/record/1065347/files"
    filename = f"{domain}/wjbhb6sif76mxfgndetew8mnrq6pw4pj.csdf"
    data_object = cp.load(filename)

    # convert the data dimension from `Hz` to `ppm`.
    data_object.dimensions[0].to("ppm", "nmr_frequency_ratio")








.. GENERATED FROM PYTHON SOURCE LINES 60-63

The variable ``data_object`` holds the 1D dataset. For comparison, let's
also import the true tensor parameter distribution from which the synthetic 1D pure
anisotropic spinning sideband cross-section amplitudes is simulated.

.. GENERATED FROM PYTHON SOURCE LINES 63-66

.. code-block:: default

    datafile = f"{domain}/xesah85nd2gtm9yefazmladi697khuwi.csdf"
    true_data_object = cp.load(datafile)








.. GENERATED FROM PYTHON SOURCE LINES 67-69

The plot of the 1D sideband cross-section along with the 2D true tensor parameter
distribution of the synthetic dataset is shown below.

.. GENERATED FROM PYTHON SOURCE LINES 69-80

.. code-block:: default


    # the plot of the 1D MAF cross-section dataset.
    _, ax = plt.subplots(1, 2, figsize=(9, 3.5), subplot_kw={"projection": "csdm"})
    ax[0].plot(data_object)
    ax[0].invert_xaxis()

    # the plot of the true tensor distribution.
    plot2D(ax[1], true_data_object, title="True distribution")
    plt.tight_layout()
    plt.show()




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /auto_examples/synthetic/images/sphx_glr_plot_1D_2_sideband_bimodal_001.png
         :alt: True distribution
         :srcset: /auto_examples/synthetic/images/sphx_glr_plot_1D_2_sideband_bimodal_001.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/synthetic/images/sphx_glr_plot_1D_2_sideband_bimodal_002.png
         :alt: plot 1D 2 sideband bimodal
         :srcset: /auto_examples/synthetic/images/sphx_glr_plot_1D_2_sideband_bimodal_002.png
         :class: sphx-glr-multi-img





.. GENERATED FROM PYTHON SOURCE LINES 81-89

Linear Inversion setup
----------------------

Dimension setup
'''''''''''''''

**Anisotropic-dimension:** The dimension of the dataset that holds the pure
anisotropic spinning sidebands.

.. GENERATED FROM PYTHON SOURCE LINES 89-91

.. code-block:: default

    anisotropic_dimension = data_object.dimensions[0]








.. GENERATED FROM PYTHON SOURCE LINES 92-94

**x-y dimensions:** The two inverse dimensions corresponding to the `x` and
`y`-axis of the `x`-`y` grid.

.. GENERATED FROM PYTHON SOURCE LINES 94-99

.. code-block:: default

    inverse_dimension = [
        cp.LinearDimension(count=25, increment="370 Hz", label="x"),  # the `x`-dimension.
        cp.LinearDimension(count=25, increment="370 Hz", label="y"),  # the `y`-dimension.
    ]








.. GENERATED FROM PYTHON SOURCE LINES 100-107

Generating the kernel
'''''''''''''''''''''

For sideband datasets, the line-shape kernel corresponds to the pure anisotropic
nuclear shielding spinning sideband spectra. Use the
:class:`~mrinversion.kernel.nmr.ShieldingPALineshape` class to generate
the sideband kernel.

.. GENERATED FROM PYTHON SOURCE LINES 107-118

.. code-block:: default

    lineshape = ShieldingPALineshape(
        anisotropic_dimension=anisotropic_dimension,
        inverse_dimension=inverse_dimension,
        channel="29Si",
        magnetic_flux_density="9.4 T",
        rotor_angle="54.735 deg",
        rotor_frequency="625 Hz",
        number_of_sidebands=32,
    )
    K = lineshape.kernel(supersampling=1)








.. GENERATED FROM PYTHON SOURCE LINES 119-124

Data Compression
''''''''''''''''

Data compression is optional but recommended. It may reduce the size of the
inverse problem and, thus, further computation time.

.. GENERATED FROM PYTHON SOURCE LINES 124-130

.. code-block:: default

    new_system = TSVDCompression(K, data_object)
    compressed_K = new_system.compressed_K
    compressed_s = new_system.compressed_s

    print(f"truncation_index = {new_system.truncation_index}")





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    compression factor = 1.032258064516129
    truncation_index = 31




.. GENERATED FROM PYTHON SOURCE LINES 131-145

Solving the inverse problem
---------------------------

Smooth-LASSO problem
''''''''''''''''''''

Solve the smooth-lasso problem. You may choose to skip this step and proceed to the
statistical learning method. Usually, the statistical learning method is a
time-consuming process that solves the smooth-lasso problem over a range of
predefined hyperparameters.
If you are unsure what range of hyperparameters to use, you can use this step for
a quick look into the possible solution by giving a guess value for the :math:`\alpha`
and :math:`\lambda` hyperparameters, and then decide on the hyperparameters range
accordingly.

.. GENERATED FROM PYTHON SOURCE LINES 145-151

.. code-block:: default


    # guess alpha and lambda values.
    s_lasso = SmoothLasso(alpha=5e-5, lambda1=5e-6, inverse_dimension=inverse_dimension)
    s_lasso.fit(K=compressed_K, s=compressed_s)
    f_sol = s_lasso.f








.. GENERATED FROM PYTHON SOURCE LINES 152-155

Here, ``f_sol`` is the solution corresponding to hyperparameters
:math:`\alpha=5\times10^{-5}` and :math:`\lambda=5\times 10^{-6}`. The plot of this
solution is

.. GENERATED FROM PYTHON SOURCE LINES 155-165

.. code-block:: default

    _, ax = plt.subplots(1, 2, figsize=(9, 3.5), subplot_kw={"projection": "csdm"})

    # the plot of the guess tensor distribution solution.
    plot2D(ax[0], f_sol / f_sol.max(), title="Guess distribution")

    # the plot of the true tensor distribution.
    plot2D(ax[1], true_data_object, title="True distribution")
    plt.tight_layout()
    plt.show()




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /auto_examples/synthetic/images/sphx_glr_plot_1D_2_sideband_bimodal_003.png
         :alt: Guess distribution, True distribution
         :srcset: /auto_examples/synthetic/images/sphx_glr_plot_1D_2_sideband_bimodal_003.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/synthetic/images/sphx_glr_plot_1D_2_sideband_bimodal_004.png
         :alt: plot 1D 2 sideband bimodal
         :srcset: /auto_examples/synthetic/images/sphx_glr_plot_1D_2_sideband_bimodal_004.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/synthetic/images/sphx_glr_plot_1D_2_sideband_bimodal_005.png
         :alt: plot 1D 2 sideband bimodal
         :srcset: /auto_examples/synthetic/images/sphx_glr_plot_1D_2_sideband_bimodal_005.png
         :class: sphx-glr-multi-img





.. GENERATED FROM PYTHON SOURCE LINES 166-170

Predicted spectrum
''''''''''''''''''

You may also evaluate the predicted spectrum from the above solution following

.. GENERATED FROM PYTHON SOURCE LINES 170-182

.. code-block:: default

    residuals = s_lasso.residuals(K, data_object)
    predicted_spectrum = data_object - residuals

    plt.figure(figsize=(4, 3))
    plt.subplot(projection="csdm")
    plt.plot(data_object, color="black", label="spectrum")  # the original spectrum
    plt.plot(predicted_spectrum, color="red", label="prediction")  # the predicted spectrum
    plt.gca().invert_xaxis()
    plt.legend()
    plt.tight_layout()
    plt.show()




.. image-sg:: /auto_examples/synthetic/images/sphx_glr_plot_1D_2_sideband_bimodal_006.png
   :alt: plot 1D 2 sideband bimodal
   :srcset: /auto_examples/synthetic/images/sphx_glr_plot_1D_2_sideband_bimodal_006.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 183-197

As you can see from the predicted spectrum, our guess isn't far from the optimum
hyperparameters. Let's create a search grid about the guess hyperparameters and run
a cross-validation method for selection.

Statistical learning of the tensors
-----------------------------------

Smooth LASSO cross-validation
'''''''''''''''''''''''''''''

Create a guess range of values for the :math:`\alpha` and :math:`\lambda`
hyperparameters.
The following code generates a range of :math:`\lambda` and :math:`\alpha` values
that are uniformly sampled on the log scale.

.. GENERATED FROM PYTHON SOURCE LINES 197-211

.. code-block:: default

    lambdas = 10 ** (-5 - 1 * (np.arange(6) / 5))
    alphas = 10 ** (-4 - 2 * (np.arange(6) / 5))

    # set up cross validation smooth lasso method
    s_lasso_cv = SmoothLassoCV(
        alphas=alphas,
        lambdas=lambdas,
        inverse_dimension=inverse_dimension,
        sigma=0.005,
        folds=10,
    )
    # run the fit using the compressed kernel and compressed signal.
    s_lasso_cv.fit(compressed_K, compressed_s)








.. GENERATED FROM PYTHON SOURCE LINES 212-218

The optimum hyper-parameters
''''''''''''''''''''''''''''

Use the :attr:`~mrinversion.linear_model.SmoothLassoCV.hyperparameters` attribute of
the instance for the optimum hyper-parameters, :math:`\alpha` and :math:`\lambda`,
determined from the cross-validation.

.. GENERATED FROM PYTHON SOURCE LINES 218-220

.. code-block:: default

    print(s_lasso_cv.hyperparameters)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    {'alpha': 3.9810717055349695e-05, 'lambda': 3.981071705534969e-06}




.. GENERATED FROM PYTHON SOURCE LINES 221-228

The cross-validation surface
''''''''''''''''''''''''''''

Optionally, you may want to visualize the cross-validation error curve/surface. Use
the :attr:`~mrinversion.linear_model.SmoothLassoCV.cross_validation_curve` attribute
of the instance, as follows. The cross-validation metric is the mean square error
(MSE).

.. GENERATED FROM PYTHON SOURCE LINES 228-243

.. code-block:: default

    cv_curve = s_lasso_cv.cross_validation_curve

    # plot of the cross-validation curve
    plt.figure(figsize=(5, 3.5))
    ax = plt.subplot(projection="csdm")
    ax.contour(np.log10(s_lasso_cv.cross_validation_curve), levels=25)
    ax.scatter(
        -np.log10(s_lasso_cv.hyperparameters["alpha"]),
        -np.log10(s_lasso_cv.hyperparameters["lambda"]),
        marker="x",
        color="k",
    )
    plt.tight_layout(pad=0.5)
    plt.show()




.. image-sg:: /auto_examples/synthetic/images/sphx_glr_plot_1D_2_sideband_bimodal_007.png
   :alt: plot 1D 2 sideband bimodal
   :srcset: /auto_examples/synthetic/images/sphx_glr_plot_1D_2_sideband_bimodal_007.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 244-249

The optimum solution
''''''''''''''''''''

The :attr:`~mrinversion.linear_model.SmoothLassoCV.f` attribute of the instance holds
the solution.

.. GENERATED FROM PYTHON SOURCE LINES 249-251

.. code-block:: default

    f_sol = s_lasso_cv.f








.. GENERATED FROM PYTHON SOURCE LINES 252-254

The corresponding plot of the solution, along with the true tensor distribution, is
shown below.

.. GENERATED FROM PYTHON SOURCE LINES 254-263

.. code-block:: default

    _, ax = plt.subplots(1, 2, figsize=(9, 3.5), subplot_kw={"projection": "csdm"})

    # the plot of the tensor distribution solution.
    plot2D(ax[0], f_sol / f_sol.max(), title="Optimum distribution")

    # the plot of the true tensor distribution.
    plot2D(ax[1], true_data_object, title="True distribution")
    plt.tight_layout()
    plt.show()



.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /auto_examples/synthetic/images/sphx_glr_plot_1D_2_sideband_bimodal_008.png
         :alt: Optimum distribution, True distribution
         :srcset: /auto_examples/synthetic/images/sphx_glr_plot_1D_2_sideband_bimodal_008.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/synthetic/images/sphx_glr_plot_1D_2_sideband_bimodal_009.png
         :alt: plot 1D 2 sideband bimodal
         :srcset: /auto_examples/synthetic/images/sphx_glr_plot_1D_2_sideband_bimodal_009.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/synthetic/images/sphx_glr_plot_1D_2_sideband_bimodal_010.png
         :alt: plot 1D 2 sideband bimodal
         :srcset: /auto_examples/synthetic/images/sphx_glr_plot_1D_2_sideband_bimodal_010.png
         :class: sphx-glr-multi-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  56.243 seconds)


.. _sphx_glr_download_auto_examples_synthetic_plot_1D_2_sideband_bimodal.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example


  .. container:: binder-badge

    .. image:: images/binder_badge_logo.svg
      :target: https://mybinder.org/v2/gh/DeepanshS/mrinversion/master?urlpath=lab/tree/docs/_build/html/../../notebooks/auto_examples/synthetic/plot_1D_2_sideband_bimodal.ipynb
      :alt: Launch binder
      :width: 150 px


  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_1D_2_sideband_bimodal.py <plot_1D_2_sideband_bimodal.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_1D_2_sideband_bimodal.ipynb <plot_1D_2_sideband_bimodal.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
